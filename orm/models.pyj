import orm.fields as fields
import orm.exceptions as exceptions
from orm.tools import exist, keys, sort, merge, copy, dict, checkBase64, configuration, ajax, date, queue, is_array, is_json, apply_domain_record, get_onchanges, query, each
from orm.pouchdb import db

env = {}
schemas = {}
raw_models = {}
onchange_models = {}
pending_sync = {}
indexed_fields = {}
read_cache = {}

def setSchema():
    db.setSchema([schemas[key] for key in schemas])

def queryInverse(field_type, records, fields, _fields):
    promises = []
    records[field_type].forEach(
    def (record):
        fields.forEach(
        def (field):
            record[field] = []
            promise = query(db, _fields[field].relation, [[_fields[field].inverse, '=', record.id]]).then( #env[_fields[field].relation].search([_fields[field].inverse, '=', record.id]).then(
            def (result):
                record[field] = record[field].concat(result)
            )
            promises.push(promise)
        )
    )
    return Promise.all(promises).then(
    def (): return records
    )

def queryFind(db, type, args, inverse=False):
    def processInverse(records):
        return queryInverse(type, records, env[type]._one2many_fields, env[type]._fields)
    if inverse: return db.rel.find(type, args).then(processInverse)
    result = query(db, type, args)
    if result == 'orm_only': return db.rel.find(type).then(processInverse)
    return result.then(
    def (ids):
      return db.rel.find(type, ids).then(processInverse)
    )

class Model():
    _name = undefined
    _inherit = False
    _rec_name = 'name'
    #_fields = {}
    #_values = {}
    #_related = {}
    #This JSON objects turnout having the same id, separating them on class initiation

    def __init__(self, _is_env, _is_singleton):
        self._fields = {}
        self._values = [{}]
        self._related = {}
        self._one2many_fields = []
        self._unstored_fields = []
        self._compute_cache = {}
        #self._read_cache = {}
        self._is_env = _is_env if _is_env != undefined else False
        self._is_singleton = _is_singleton if _is_singleton != undefined else False
        self._inherited_keys = []
        self._context = {}
        self._search_count = 0
        self.toJSON = def (): return self.ids
        self._pending_promises = []
        self._wait_promise = def (): return Promise.all(self._pending_promises).then(def (): self._pending_promises = [];)
        if exist(self._inherit) and exist(raw_models[self._inherit]) and env[self._inherit] != True:
           if not exist(self._name):
              self._name = self._inherit
           newmodel = self
           oldconstructor = self.constructor
           models = raw_models[newmodel._inherit]
           if oldconstructor not in models:
              models.push(oldconstructor)
           for raw_model in models:
               for key in Object.getOwnPropertyNames(raw_model.prototype):
                   if key[:2] != '__' and key not in ['_inherit', 'inherited_constructor', 'values']:
                      self[key] = raw_model.prototype[key]
                      self._inherited_keys.push(key)
           self._name = newmodel._name
           self._is_env = False
           if exist(env[self._name]) and env[self._name].constructor != self.constructor:
              del env[self._name]
           #self.inherited_constructor = self.constructor
        if 'Model' not in env:
           env['Model'] = Model
        if 'context' not in env:
            env['context'] = {}
        if self._name not in env:
           env[self._name] = True
           v'Object.defineProperty(env, self._name, {get: function() {return new self.constructor(true)}})'
           #env[self._name]._is_env = True
        self.env = env
        #if self._is_env:
        #   return
        schema = {'singular': self._name, 'plural': self._name}
        schemas[self._name] = schema
        #Reserved fields
        reserved = ['id', '_id', 'rev', '_rev', 'ids']
        if self.name == undefined and self._rec_name != 'name':
           self.constructor.prototype.name = copy(self[self._rec_name])
           self.constructor.prototype.name.related = self._rec_name
           self.constructor.prototype.name.store = True
        self._fields.id = fields.Char(string="ID", related='_id', store=True)
        self._fields._id = fields.Char(string="ID (Raw)")
        self._fields.ids = fields.Data(string="IDs")
        self._fields.rev = fields.Char(string="DB Revision Number", related='_rev', store=True)
        self._fields._rev = fields.Char(string="DB Revision Number")
        valid_fields = [key for key in Object.getOwnPropertyNames(self.constructor.prototype) if key[0] != '_' and key not in ['constructor', 'env', 'values']].concat(reserved).concat(self._inherited_keys)
        valid_fields.forEach(
        def (key):
            if not exist(self[key]) or type(self[key]) != Object or (type(self[key]) == Object and 'compute' not in self[key]):
               return
            #if key in self._fields:
            #   self[key] = self._fields[key]
            if self[key].type in ['many2one', 'one2many', 'many2many', 'one2one']:
               if not schema.relations:
                  schema.relations = {}
               relation = 'belongsTo'
               if self[key].type in ['one2many', 'many2many']:
                  relation = 'hasMany'
               if self[key].type != 'one2many':
                  schema.relations[key] = {relation: {'type': self[key].relation, 'options': {'async': True}}} #Turning async into false since one2many doesn't work
               else:
                  schema.relations[key] = {relation: {'type': self[key].relation, 'options': {'async': True, 'queryInverse': self[key].inverse}}}
                  self._one2many_fields.push(key)
               if type == 'belongsTo':
                  db.createIndex({'index': {'fields': ['data.'+key, '_id']}})
            self._fields[key] = self[key]
            if self[key].index:
               if not indexed_fields[key]:
                  indexed_fields[key] = True
                  db.createIndex({'index': {'fields': ['data.' + key, '_id']}})
            if self[key].type == 'data' and is_array(self[key].index_fields) and self[key].index_fields.length:
               for field in self[key].index_fields:
                   field = key + '.' + field
                   if not indexed_fields[field]:
                      db.createIndex({'index': {'fields': ['data.' + field, '_id']}})
            if self._is_singleton and not self._is_env:
               if exist(self._fields[key].related):
                  if not exist(self._related[self._fields[key].related]):
                     self._related[self._fields[key].related] = []
                  self._related[self._fields[key].related].push(key)
               if v'typeof self[key].defaults' != 'function':
                  defaults = self[key].defaults
                  if is_array(defaults): defaults = copy(defaults)
                  self._values[0][key] = defaults
               else:
                  result = self[key].defaults.apply(self, [self])
                  if result and type(result) == Promise:
                     result.then(
                     def (value):
                         if not exist(self[key]): self[key] = value
                     )
                     self._pending_promises.push(result)
                  else:
                     self._values[0][key] = result
            field = self[key]
            if not field.store: self._unstored_fields.push(key)
            #self[key] = self._fields[key].defaults
            del self[key]
            Object.defineProperty(self, key, {
              'get':
              def ():
                  result = None
                  ids = self.ids
                  if ids.length == 0:
                     result = self._values[0][key]
                  elif ids.length == 1:
                     if field.compute and v'typeof field.compute' == 'function':
                        if field.store and key in self._compute_cache: return self._compute_cache[key]
                        result = field.compute.apply(self, [self])
                        if field.store:
                           self._compute_cache[key] = result
                           if result and type(result) == Promise:
                              result.then(
                              def (result):
                                  self._compute_cache[key] = result
                                  self._values[ids[0]][key] = result
                              )
                           else:
                              self._values[ids[0]][key] = result
                        return result
                     result = self._values[ids[0]][key]
                  if key in self._one2many_fields and not exist(value): value = []
                  return result
              ,
              'set':
              def (value):
                  if not field.store: return
                  ids = self.ids
                  old_value = None
                  if ids.length == 0:
                     old_value = self._values[0][key]
                     self._values[0][key] = self.adapt(key, value, self._values[0]) if key != 'id' else id
                  elif ids.length == 1:
                     old_value = self._values[ids[0]][key]
                     self._values[ids[0]][key] = self.adapt(key, value, self._values[ids[0]])
                  if ids.length < 2 and value != old_value and onchange_models[self._name] and onchange_models[self._name][key]:
                     for method in onchange_models[self._name][key]:
                         result = self[method].apply(self)
                         if result and type(result) == Promise:
                            self._pending_promises.push(result)
            })
        )
        #if exist(self._fields):
        #   self.env[self._name]._fields = self._fields
        #try:
        #   setSchema()
        #except:
        #   pass
        if exist(self._name):
           if not exist(raw_models[self._name]):
              raw_models[self._name] = []
           if self.constructor not in raw_models[self._name]:
              raw_models[self._name].push(self.constructor)
        if 'values' in Object.getOwnPropertyNames(self):
           return
        Object.defineProperty(self, 'ids', {
        'get': def ():
                   if not is_array(self.values):
                      if self._values[0].id:
                         if not self._values[self._values[0].id]: self._values[self._values[0].id] = self._values[0]
                         return [self._values[0].id.toString()]
                      return []
                   else:
                      ids = []
                      for object in self._values:
                          if object.id:
                             ids.push(object.id.toString())
                             if not self._values[object.id]: self._values[object.id] = object
                      return ids
        ,
        'set': def (): return
        })
        Object.defineProperty(self, 'id', {
        'get': def ():
                   if self._values.length == 1 and self._values[0].id:
                      if not self._values[self._values[0].id]: self._values[self._values[0].id] = self._values[0]
                      return self._values[0].id
                   return None
        ,
        'set': def (id):
                   if self._values.length == 1 and not self._values[0].id:
                      id = id.toString()
                      self._values[0].id = id
                      self._values[id] = self._values[0]
        })
        Object.defineProperty(self, 'values', {
        'get': def ():
                   values = self._values
                   if values.length == 1:
                      values = self._values[0]
                      values._search_count = self._search_count
                   else:
                      for value in values:
                          value._search_count = self._search_count
                   return values
        ,
        'set': def (new_value):
                   if new_value and '_search_count' in new_value:
                      del new_value._search_count
                   if not exist(new_value):
                      return
                   self._is_env = False
                   if not is_array(new_value):
                      self._is_singleton = True
                      self._values = [new_value]
                      for key in self._fields:
                          if key in new_value and key not in self._unstored_fields:
                             self._values[0][key] = self.adapt(key, new_value[key], self._values[0])
                      if new_value.id:
                         self._values[new_value.id] = self._values[0]
                         self._values[0].id = new_value.id
                   else:
                      #if exist(new_value):
                      #   self._search_count = new_value[0]._search_count
                      self._is_singleton = False
                      new_array = []
                      for value in new_value:
                          for key in self._fields:
                              if key in value and key not in self._unstored_fields:
                                 value[key] = self.adapt(key, value[key], value)
                          if value.id: 
                             new_array[value.id] = value
                          new_array.push(value)
                      self._values = new_array
                      #self.ids = [object.id for object in new_value]
        })
        Object.defineProperty(self, 'length', {'get':
        def (): 
            if self._is_env:
               return 0
            elif self._values.length == 1:
               if exist(self._values[0].id) or Object.keys(self._values[0]).length > 0:
                  return 1
               return 0
            else:
               return self._values.length
        })
        if not onchange_models[self._name]:
           onchange_models[self._name] = get_onchanges(self)
        #Disabling seal and freeze altogether because they cause bugs
        #v'Object.seal(self)'
        #v'Object.freeze(self._fields)'
        #v'Object.seal(self._values)'

    def __iter__(self):
        length = self.length
        if self._is_env or length < 1:
           return iter([])
        elif length == 1:
           return iter([self])
        def yield_record(self):
            for index in range(self.values.length):
                result = self.env[self._name]
                result.values = self.values[index]
                result._search_count = self.values[index]._search_count
                yield result
        return yield_record(self)

    def __super__(self, method_name):
        method = env.Model.prototype[method_name]
        if not self._inherit:
           if not method:
              return def (): return Promise(def (resolve): resolve();)
        else:
           method = raw_models[self._inherit][-1].prototype[method_name]
        return def (*args, **kwargs):
            original_method = self[method_name]
            self[method_name] = method
            result = self[method_name].bind(self)(*args, **kwargs)
            if exist(result) and type(result) == Promise:
               return result.then(
               def (result):
                   self[method_name] = original_method
                   return result
               )
            self[method_name] = original_method
            return result

    def __sync__(self):
        promises = self.map(
        def (record):
            if not record.id: return
            if pending_sync[record.id]: return
            pending_sync[record.id] = True
            def remove_pending(): del pending_sync[record.id]
            values = copy(record.values)
            return db.get(db.rel.makeDocID({'type': self._name, 'id': record.id})).then(
            def (doc):
                del values._id
                del values._rev
                del values.rev
                values.rev = doc._rev
                return db.rel.save(self._name, values).then(remove_pending)
            ).catch(
            def (error):
                del values._id
                del values._rev
                del values.rev
                return db.rel.save(self._name, values).then(remove_pending)
            )
        )
        return Promise.all(promises)

    def __view__(self, view, view_type):
        return view

    def browse(self, ids=False, is_singleton=True, is_client=configuration.client, is_env=False):
        if not exist(ids):
           if ids in [[], None, undefined]:
              return Promise(
              def (resolve, reject):
                   #resolve(v'new self.constructor(is_env, is_singleton)')
                   resolve(self.env[self._name])
              )
           result = v'new self.constructor(is_env, is_singleton)'
           result._context = self._context
           return result
        elif is_client:
           return ajax('post', 'json', configuration.url + '/api/browse', {'login': self.env.user.login, 'password': self.env.user.password, 'encrypted': True, 'model': self._name, 'ids': ids, 'context': self._context}, self._context).then(
           def (result):
               if result.error: configuration.exception(new exceptions.ServerError(result.error, result.error_type))
               record = self.browse(is_singleton=not is_array(result.values), is_env=True)
               record.values = result.values
               if is_array(result.values):
                  record._search_count = result.values[0]._search_count
               else:
                  record._search_count = result.values._search_count
               record.__sync__().catch(def (error): console.error(error);)
               return record
           ).catch(
           def (error):
               configuration.warning(error, True)
               return self.browse(ids, is_client=False)
           )
        elif is_array(ids):
           #result = self.browse()
           if ids.length > 1:
              v'var result = new self.constructor(false, false)'
              return queryFind(db, result._name, ids, inverse=True).then(
              def (record):
                  #record = queryInverse(result._name, record, result._one2many_fields, result._fields)
                  #result.ids = ids
                  result.values = record[result._name]
                  result._search_count = record[result._name].length
                  return result
              )
           else:
              ids = ids[0]
        if type(ids) == String:
           result = self.env[self._name]
           #return db.get(db.rel.makeDocID({'type': result._name, 'id': ids})).then(
           return queryFind(db, result._name, ids, inverse=True).then(
           def (record):
               #record = queryInverse(result._name, record, result._one2many_fields, result._fields)
               #result.id = ids
               #record.data.id = db.rel.parseDocID(record._id).id
               #record.data.rev = record._rev
               result.values = record[result._name][0]#.data
               result._search_count = record[result._name].length
               return result
           )
        return result

    def search(self):
        args = Array.prototype.slice.call(arguments)
        options = copy(self._context)
        if options.is_client == undefined:
           options.is_client = configuration.client
        if exist(self.env.context.active_limit):
           options.limit = options.limit or self.env.context.active_limit
        if exist(self.env.context.active_index):
           options.index = options.index or self.env.context.active_index
        if exist(self.env.context.active_sort):
           options.order = options.order or self.env.context.active_sort
        if exist(options.is_client):
           del options.is_client
           options.fields = Object.keys(self._fields)
           return ajax('post', 'json', configuration.url + '/api/search', {'login': self.env.user.login, 'password': self.env.user.password, 'encrypted': True, 'model': self._name, 'args': args, 'options': options}, self._context).then(
           def (result):
               if result.error: configuration.exception(new exceptions.ServerError(result.error, result.error_type))
               record = self.browse(is_singleton=not is_array(result.values), is_env=True)
               record.values = result.values
               if is_array(result.values):
                  record._search_count = result.values[0]._search_count
               else:
                  record._search_count = result.values._search_count
               #self.with_context(no_preload=True).browse(self.ids)
               record.__sync__().catch(def (error): console.error(error);)
               return record
           ).catch(
           def (error):
               configuration.warning(error, True)
               return self.with_context(is_client=False).search(*args)
           )
        def query(record):
            return apply_domain_record(*args, record=record)
        result = self.env[self._name]
        if options.limit == 1:
           #TODO index implementation
           if options.index > 0:
              return Promise(
              def (resolve, reject):
                  resolve(result)
              )
           return queryFind(db, result._name, args).then(
           def (records):
               #records = queryInverse(result._name, records, result._one2many_fields, result._fields)
               if exist(options.order):
                  for order in options.order.split(','):
                      order, desc = order.split(' ')
                      desc = True if desc == 'desc' else False
                      records[result._name] = sort(records[result._name], order, desc)
               record = records[result._name].find(query)
               result._search_count = 1 if record else 0
               #result.id = record.id
               result.values = record
               return result
           )
        else:
           return queryFind(db, result._name, args).then(
           def (records):
               v'var result = new self.constructor(true, false)'
               #records = queryInverse(result._name, records, result._one2many_fields, result._fields)
               result._search_count = records[result._name].length
               if records[result._name].length > 1:
                  values = records[result._name].filter(query)
                  result._search_count = values.length
                  if exist(options.limit) and type(options.limit) == Number:
                     start = 0
                     if exist(options.index) and type(options.index) == Number:
                        start = options.index * options.limit
                        options.limit = (options.index + 1) * options.limit
                     result.values = values.slice(start, options.limit)
                  else:
                     result.values = values
                  #result.ids = [value.id for value in result._values]
                  if exist(options.order):
                     for order in options.order.split(','):
                         order, desc = order.split(' ')
                         desc = True if desc == 'desc' else False
                         result.sort_by(order, desc)
                  return result
               else:
                  result = self.env[self._name]
                  if options.index > 0:
                     return result
                  record = records[result._name].find(query)
                  #result.id = record.id
                  result.values = record
                  if exist(options.order):
                     for order in options.order.split(','):
                         order, desc = order.split(' ')
                         desc = True if desc == 'desc' else False
                         result.sort_by(order, desc)
                  return result
           )
        return result

    def read(self, format, fields, without_null):
        if format:
           promises = []
           new_values = []
           self.map(
           def (record):
               value = record.values
               oldvalue = value
               value = copy(value)
               if not value.id:
                  value._original_object_for_id = oldvalue
               new_values.push(value)
               queue(keys(value).concat(self._unstored_fields),
               def (key, next):
                   if fields and key not in fields: return next()
                   field = self._fields[key]
                   def after_promise(result):
                       if result != undefined: value[key] = result
                       if not field or (value[key] == None and field.type != 'float'):
                          if without_null: value[key] = ''
                          return next()
                       if field.type == 'date':
                          value[key] = date.format(v'new Date(value[key])', 'Y-m-d')
                       elif field.type == 'datetime':
                          value[key] = date.format(v'new Date(value[key])', 'Y-m-d H:M:S')
                       elif field.type == 'float' and Number.isInteger(value[key]):
                          value[key] = value[key].toFixed(2)
                       elif field.type == 'selection':
                          selections = field.selection.apply(None) if field.selection and type(field.selection) == Function else field.selection
                          value[key] = tools.dict(selections)[value[key]]
                          if not value[key] and without_null: value[key] = ''
                       elif field.type in ['many2many', 'many2one', 'one2many', 'one2one']:
                          if not read_cache[field.relation]: read_cache[field.relation] = {}
                          promise = None
                          #push = False
                          if read_cache[field.relation] and read_cache[field.relation][JSON.stringify(value[key])]:
                             promise = read_cache[field.relation][JSON.stringify(value[key])]
                          if not promise:
                             promise = self.env[field.relation].browse(value[key])
                             #push = True
                             read_cache[field.relation][JSON.stringify(value[key])] = promise
                          promise.then(
                          def (records):
                              original_value = value[key]
                              names = []
                              for record in records:
                                  names.push(record[record._rec_name or 'name'])
                              value[key] = names.join(', ')
                              return records
                          )
                          if result != undefined: return promise
                          promises.push(promise)
                       if not result: next()
                   if field.compute:
                      record = self.find(value.id or value._original_object_for_id)
                      value[key] = record[key]
                      if value[key] and type(value[key]) == Promise:
                         promises.push(value[key].then(after_promise))
                         return next()
                   after_promise()
               )
           )
           return Promise.all(promises).then(
           def ():
               nonlocal read_cache
               read_cache = {}
               return new_values
           )
        if self._is_env:
           return {}
        if self.length > 1: return [record.read() for record in self]
        return {key: self.adapt(key, self._values[0][key]) for key in self._values[0] if key in self._fields}

    def adapt(self, key, value, values):
        if not values: values = self._values[0] if self._values.length < 2 else {}
        #if key == 'id':
        #   value = self._fields[key].value
        if self._fields[key].type in ['char', 'text']:
           if not exist(value):
              value = ""
           else:
              value = v'String(value)'
        elif self._fields[key].type == 'integer':
           oldvalue = value
           value = parseInt(value)
           if isNaN(value):
              raise Error("Not a valid Number " + oldvalue + " on field " + key + " on model " + self._name)
        elif self._fields[key].type == 'float':
           oldvalue = value
           value = parseFloat(value)
           if isNaN(value):
              raise Error("Not a valid Number " + oldvalue + " on field " + key + " on model " + self._name)
        elif self._fields[key].type == 'boolean':
           if value in ['true', 'True']:
              value = True
           elif value in ['false', 'False', None, undefined]:
              value = False
           elif value and type(value) == String:
              raise Error("Not a valid Boolean " + value + " on field " + key + " on model " + self._name)
           else:
              value = Boolean(value)
        elif self._fields[key].type == 'binary':
           if exist(value) and not checkBase64(value):
              raise Error("Not a valid base64 on field " + key + " on model " + self._name)
        elif self._fields[key].type == 'selection':
           if not exist(value):
              value = None
           elif self._fields[key].selection and is_array(self._fields[key].selection) and value not in dict(self._fields[key].selection):
              raise Error("Incorrect value " + value + " on field " + key + " on model " + self._name)
        elif self._fields[key].type in ['date', 'datetime']:
           if not exist(value):
              value = None
           elif type(value) == Date:
              value = value.toISOString()
           elif type(value) == String:
              try:
                  value = v'new Date(value).toISOString()'
              except:
                  raise Error("Can't parse Date " + value + " on field " + key + " on model " + self._name)
           else:
              raise Error("Can't parse Date " + value + " on field " + key + " on model " + self._name)
           #if exist(value) and self._fields[key].type == 'date':
           #   value = value.split('T')[0] + 'T00:00:00.000Z'
        elif self._fields[key].type == 'data':
           if v'typeof value' != 'object':
              if type(value) == String:
                 try:
                     value = JSON.parse(value)
                 except:
                     raise Error("Can't parse Data " + value + " on field " + key + " on model " + self._name)
              else:
                 raise Error("Can't parse Data " + value + " on field " + key + " on model " + self._name)
        elif self._fields[key].type in ['many2one', 'one2one']:
           if not exist(value):
              return None
           elif v'value instanceof env.Model' == True:
              if value.id:
                 value = value.id
           elif is_array(value) and value.length > 0:
                value = value[0]
        elif self._fields[key].type in ['many2many', 'one2many']:
           if not exist(value):
              value = []
           elif v'value instanceof env.Model' == True:
              value = value.ids
        #Related operation
        if self._fields[key].store in [True, None]:
           if exist(self._fields[key].related):
              values[self._fields[key].related] = value
           if exist(self._related[key]):
              for field in self._related[key]:
                  values[field] = value
        return value

    def update(self, values=False, no_onchange=False):
        if self._is_env:
           return
        if not exist(values): return
        if is_array(values):
           if self._values.length != values.length:
              self.values = values
           else:
              index = 0
              for record in self:
                  record.update(values[index], no_onchange=no_onchange)
                  index += 1
           return
        for record in self:
            for key in values:
                if key != 'id' and self._fields[key] and key not in self._unstored_fields:
                   if not no_onchange: record[key] = values[key]
                   else: record._values[0][key] = self.adapt(key, values[key], values)
        if self.length == 1 and values.id: self.id = values.id
        return self

    def queue(self, method):
        if self._is_env or not exist(self):
           return
        records = [record for record in self]
        v'var index = 0'
        def next():
            v'index += 1'
            if index < records.length and records[index]?:
               return method(records[index], next)
            return self
        result = method(records[index], next)
        return result

    def create(self, values=False, is_client=configuration.client):
        self.update(no_onchange=True)
        if not exist(values):
           values = self.read()
        if not exist(values) and self.length < 1:
           return
        for value in each(values):
            for key in self._fields:
                if not self._fields[key].store: continue
                defaults = self._fields[key].defaults
                if v'typeof defaults' == 'function':
                   if not value[key]: defaults = defaults.apply(self, [self])
                   else: continue
                if not value[key] and (defaults and type(defaults)) != Promise: value[key] = defaults
        if self._is_env:
           self = self.browse()
           self.update(values, no_onchange=True)
        required_fields = []
        for value in each(values):
            for key in self._fields:
                if self._fields[key].required and value[key] != False and not exist(value[key]):
                   required_fields.push(key)
        if required_fields.length > 0: raise exceptions.RequiredError(required_fields, self)
        if is_client:
           return ajax('post', 'json', configuration.url + '/api/create', {'login': self.env.user.login, 'password': self.env.user.password, 'encrypted': True, 'model': self._name, 'values': values}, self._context).then(
           def (result):
               if result.error: configuration.exception(new exceptions.ServerError(result.error, result.error_type))
               self.update(result.values, no_onchange=True)
               self._compute_cache = {}
               #self.with_context(no_preload=True).browse(self.ids)
               self.__sync__().catch(def (error): console.error(error);)
               return self
           ).catch(
           def (error):
               configuration.exception(error)
               #return Exception("There is some error")
               #return self.create(values, is_client=False)
               raise error
           )
        if not is_array(values):
           del values['id']
           del values['rev']
           del values['_id']
           del values['_rev']
        def process_result(record):
            #queryInverse(self._name, record, self._one2many_fields, self._fields)
            self.update(record[self._name][0], no_onchange=True)
            return self
        if is_array(values):
           promises = []
           for value in values:
               promise = self.env[self._name].create(value)
               promises.push(promise)
           records = self.env[self._name]
           return Promise.all(promises).then(
           def (recordsets):
               for record in recordsets:
                   records.add(record)
               return records
           )
        return db.rel.save(self._name, values).then(process_result)

    def write(self, values=False, is_client=configuration.client):
        if not exist(self.id) and not exist(self.ids):
           return self
        self.update(no_onchange=True)
        if not exist(values):
           values = self.read()
        elif self.length < 2:
           self.update(values, no_onchange=True)
           values = self.read()
        if not exist(values) or self.length < 1:
           return
        required_fields = []
        for value in values if is_array(values) else [values]:
            for key in self._fields:
                if self._fields[key].required and key in value and value[key] != False and not exist(value[key]):
                   required_fields.push(key)
        if required_fields.length > 0: raise exceptions.RequiredError(required_fields, self)
        if is_client:
           return ajax('post', 'json', configuration.url + '/api/write', {'login': self.env.user.login, 'password': self.env.user.password, 'encrypted': True, 'model': self._name, 'ids': self.ids, 'values': values}, self._context).then(
           def (result):
               if result.error: configuration.exception(new exceptions.ServerError(result.error, result.error_type))
               self.update(result.values, no_onchange=True)
               self._compute_cache = {}
               #self.with_context(no_preload=True).browse(self.ids)
               self.__sync__().catch(def (error): console.error(error);)
               return self
           ).catch(
           def (error):
               configuration.exception(error)
               #return self.write(values, is_client=False)
               #return Exception("There are some error")
               raise error
           )
        if self.length == 1 and is_json(values):
           return db.get(db.rel.makeDocID({'type': self._name, 'id': self.id})).then(
           def (record):
               #return db.put(merge(values, {'_id': record._id, '_rev': record._rev}))
               del values._id
               del values._rev
               del values.rev
               values.rev = record._rev
               return db.rel.save(self._name, values).then(
               def (result):
                   self.update(values, no_onchange=True)
                   return self
               )
           )
        if is_array(values) and self.length != values.length:
           return
        else:
           value = None
           if is_json(values):
              value = values
           promises = []
           index = 0
           for record in self:
               promise = record.write(value or values[index])
               promises.push(promise)
               index += 1
           records = self.env[self._name]
           return Promise.all(promises).then(
           def (recordsets):
               for record in recordsets:
                   records.add(record)
               return records
           )
        return self

    def unlink(self, is_client=configuration.client):
        if not exist(self.id) and not exist(self.ids):
           return
        if is_client:
           return ajax('post', 'json', configuration.url + '/api/unlink', {'login': self.env.user.login, 'password': self.env.user.password, 'encrypted': True, 'model': self._name, 'ids': [record.id for record in self.__iter__()]}, self._context).then(
           def (result):
               if result.error: configuration.exception(new exceptions.ServerError(result.error, result.error_type))
               return True
           ).catch(
           def (error):
               configuration.warning(error, True)
               #return self.unlink(is_client=False)
               #return False
               raise error
           )
        if self.length == 1:
           return db.get(db.rel.makeDocID({'type': self._name, 'id': self.id})).then(
           def (record):
               record._deleted = True
               return db.put(record)
           )
        else:
           processes = []
           for record in self:
               processes.push(record.unlink())
           return Promise.all(processes)
           #for value in self._values:
           #    value['_deleted'] = True
           #return db.bulkDocs(self._values)
        return True

    def sudo(self, uid):
        if configuration.client: return self
        if not uid: uid = 1
        return self.with_context(uid=uid)

    def with_context(self, *args, **kwargs):
        for arg in args:
            for key in arg:
                self._context[key] = arg[key]
        for key in kwargs:
            self._context[key] = kwargs[key]
        return self

    def sort_by(self, field, desc=False):
        if self.length < 2:
           return self
        self.values.sort(
        def (a, b):
             if desc:
                c = a
                d = b
                a = d
                b = c
             if a[field] != 0 and not a[field] and b[field]:
                return -1
             elif b[field] != 0 and not b[field] and a[field]:
                return 1
             if a[field] < b[field]:
                return -1
             elif a[field] > b[field]:
                return 1
             return 0
        )
        return self

    def add(self):
        ids = self.ids
        unsaved_records = []
        values = self.values if is_array(self.values) else [self.values] if self.length > 0 else []
        recordsets = Array.prototype.slice.call(arguments)
        for records in recordsets:
            if records._name != self._name:
               raise Error('Not the same model')
            if records.length < 1: continue
            #if not records.id: records = [records]
            for record in records:
                if record.id:
                   if record.id in ids: continue
                   ids.push(record.id)
                else:
                   if unsaved_records.indexOf(record.values) != -1: continue
                   unsaved_records.push(record.values)
                values.push(record.values)
        self.values = values if values.length > 1 else values[0]
        return self

    def find(self, id):
        value = False
        if id and type(id) == String:
           value = self._values[id]
        elif id and type(id) == Object:
           value = self._values.find(
           def (object):
               return v'object === id'
           )
        else:
           return self.env[self._name]
        record = self.env[self._name]
        record.values = value
        return record

    def filter(self, filter_function):
        records = self.env[self._name]
        for record in self:
            if filter_function(record): records.add(record)
        return records

    def map(self, map_function):
        values = []
        for record in self:
            values.push(map_function(record))
        return values
