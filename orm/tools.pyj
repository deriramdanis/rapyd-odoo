def keys(object, sort=False):
    if exist(sort):
       object = [[key, object[key][sort]] for key in object]
       object.sort(
       def (a, b):
           return a[1] - b[1]
       )
       return [item[0] for item in object]
    return Object.keys(object)

def sort(object, key, desc=False):
    if object.length < 2:
       return object
    object.sort(
    def (a, b):
         if desc:
            c = a
            d = b
            a = d
            b = c
         if a[key] < b[key]:
            return -1
         elif a[key] > b[key]:
            return 1
         return 0
    )
    return object

def merge(*args, **kwargs):
    if kwargs.reverse: args = args.reverse()
    args = [arg for arg in args if arg]
    target = args[0]
    for object in args[1:]:
        for key in object:
           target[key] = object[key]
    return target
    #target = args[0]
    #for object in args[1:]:
    #    target = Object.assign(target, object)
    #return target

def copy(object):
    if is_array(object):
       return [copy(value) for value in object]
    elif is_json(object):
       return {key: copy(object[key]) for key in object}
    return object

def dict(entries):
    #This is a function to imitate python's dict function that create a dict from a key-value pair
    object = {}
    for entry in entries:
        object[entry[0]] = entry[1]
    return object

def btoa(string):
    if v'typeof window' != 'undefined': return window.btoa(string)
    return require('buffer').Buffer.from(string, 'binary').toString('base64')

def atob(string, buffer):
    if v'typeof window' != 'undefined': return window.atob(string)
    result = require('buffer').Buffer.from(string, 'base64')
    if not buffer: result = result.toString('binary')
    return result

def checkBase64(string):
    try:
       return btoa(atob(string)) == string
    except:
       return False

def exist(object):
    #if object in ['', False, None, undefined, 0.0, {}, []]:
    if not object or object == {} or object == []:
       return False
    elif v'typeof object === "object"' and v'typeof object.length === "number"':
       return object.length > 0
    return True

def empty(object):
    return exist(object) == False

def wait():
    args = Array.prototype.slice.call(arguments)
    if args.length == 1 and is_array(args[0]): args = args[0]
    return Promise.all(args)

def wait_exist(fn):
    return Promise(
    def (resolve, reject):
        def clear(id):
            clearInterval(id)
            resolve();
        interval = setInterval(
        def ():
            if fn(): clear(interval)
        , 0)
    )

def max():
    objects = Array.prototype.slice.call(arguments)
    maximum = None
    for object in objects:
        if not object: continue
        for compare in objects:
            if not compare: continue
            if object == compare: continue
            if not maximum and object > compare: maximum = object
            elif object > compare and object > maximum: maximum = object
    return maximum

def min():
    objects = Array.prototype.slice.call(arguments)
    minimum = None
    for object in objects:
        if not object: continue
        for compare in objects:
            if not compare: continue
            if object == compare: continue
            if not minimum and object < compare: minimum = object
            elif object < compare and object < minimum: minimum = object
    return minimum

def is_array(object):
    return Array.isArray(object)

def is_json(object):
    if v'typeof object' == 'object' and object != None:
       if v'typeof Object.getPrototypeOf' == 'function':
          prototype = Object.getPrototypeOf(object)
          return prototype == Object.prototype or prototype == None
       else:
          return Object.prototype.toString.call(object) == '[object Object]'
    return False

def apply_domain():
    domains = Array.prototype.slice.call(arguments)
    results = []
    is_or = False
    previously_or = False
    or_index = 1
    or_count = 0
    for args in domains:
        if not args or not args.length: continue
        if args == '|':
           is_or = True
           or_index = 1
           continue
        if args[1] == '=':
           if args[2] != False:
              results.push(args[0] == args[2])
           else:
              results.push(not exist(args[0]))
        elif args[1] == '!=':
             if args[2] != False:
                results.push(args[0] != args[2])
             else:
                results.push(exist(args[0]))
        elif args[1] == '>':
             results.push(args[0] > args[2])
        elif args[1] == '>=':
             results.push(args[0] >= args[2])
        elif args[1] == '<':
             results.push(args[0] < args[2])
        elif args[1] == '<=':
             results.push(args[0] <= args[2])
        elif args[1] == 'in' and is_array(args[2]):
             results.push(args[0] in args[2])
        elif args[1] == 'not in' and is_array(args[2]):
             results.push(args[0] not in args[2])
        elif args[1] == 'like':
             results.push(args[2] in args[0])
        elif args[1] == 'ilike':
             results.push(str(args[2]).toLowerCase() in str(args[0]).toLowerCase())
        if previously_or:
           or_1 = results[-2]
           or_2 = results[-1]
           results.pop()
           results.pop()
           results.push(or_1 or or_2)
        if or_index == 2:
           or_index = 1
           is_or = False
        elif is_or:
           or_index += 1
           previously_or = True
        else:
           previously_or = False
    return results.every(
    def (result): return result
    )

def apply_domain_record(*domains, **kwargs):
    record = kwargs.record
    results = []
    is_or = False
    previously_or = False
    or_index = 1
    or_count = 0
    for args in domains:
        if not args or not args.length: continue
        if args == '|':
           is_or = True
           or_index = 1
           continue
        if args[1] == '=':
           if args[2] != False:
              results.push(record[args[0]] == args[2])
           else:
              results.push(not exist(record[args[0]]))
        elif args[1] == '!=':
             if args[2] != False:
                results.push(record[args[0]] != args[2])
             else:
                results.push(exist(record[args[0]]))
        elif args[1] == '>':
             results.push(record[args[0]] > args[2])
        elif args[1] == '>=':
             results.push(record[args[0]] >= args[2])
        elif args[1] == '<':
             results.push(record[args[0]] < args[2])
        elif args[1] == '<=':
             results.push(record[args[0]] <= args[2])
        elif args[1] == 'in' and is_array(args[2]):
             results.push(record[args[0]] in args[2])
        elif args[1] == 'not in' and is_array(args[2]):
             results.push(record[args[0]] not in args[2])
        elif args[1] == 'like':
             results.push(args[2] in record[args[0]])
        elif args[1] == 'ilike':
             results.push(str(args[2]).toLowerCase() in str(record[args[0]]).toLowerCase())
        if previously_or:
           or_1 = results[-2]
           or_2 = results[-1]
           results.pop()
           results.pop()
           results.push(or_1 or or_2)
        if or_index == 2:
           or_index = 1
           is_or = False
        elif is_or:
           or_index += 1
           previously_or = True
        else:
           previously_or = False
    return results.every(
    def (result): return result
    )

def get_onchanges(self):
    onchanges = {}
    for key in Object.keys(self.constructor.prototype):
        if key in self._fields: continue
        if self[key] and v'typeof self[key]' == 'function' and self[key]._onchange_function:
           for field in self[key]._onchange_fields:
               if not exist(onchanges[field]):
                  onchanges[field] = []
               onchanges[field].push(self[key].name)
    return onchanges

def each(arraylike):
    if is_array(arraylike) or v'typeof arraylike.length !== "undefined"': return arraylike
    return [arraylike]

def queue(values, method):
    v'var index = 0'
    def next():
        v'index += 1'
        if index < values.length and values[index]?:
           return method(values[index], next)
        #return
    result = method(values[index], next)
    return result

def create_worker(code):
    if v"typeof window === 'undefined'":
       return
    URL = window.URL or window.webkitURL
    blob = False
    try:
        blob = new Blob([code], {'type': 'application/javascript'})
    except:
        BlobBuilder = window.BlobBuilder or window.WebKitBlobBuilder or window.MozBlobBuilder
        blob = BlobBuilder()
        blob.append(code)
        blob = blob.getBlob()
    return v'new Worker(URL.createObjectURL(blob))'

def exception(error):
    console.error(error)

def warning(error, offline):
    #if offline == undefined:
    #   offline = False
    if offline:
       console.log('You are offline')
    console.error(error)

def pad(num, size=2):
    s = num + ""
    while s.length < size:
        s = "0" + s
    return s

date = {}

def format_date(object, format):
    self = {}
    self.selectedDateObj = object
    formats = {
                # hours with leading zero e.g. 03
                'H': def (): return pad(self.selectedDateObj.getHours());,

                # AM/PM
                'K': def (): return self.selectedDateObj.getHours() > 11 ? "PM" : "AM";,

                # seconds 00-59
                'S': def (): return pad(self.selectedDateObj.getSeconds());,

                # unix timestamp
                'U': def (): return self.selectedDateObj.getTime() / 1000;,

                # full year e.g. 2016
                'Y': def (): return self.selectedDateObj.getFullYear();,

                # day in month, padded (01-30)
                'd': def (): return pad(self.formats.j());,

                # hour from 1-12 (am/pm)
                'h': def (): return self.selectedDateObj.getHours() % 12 ? self.selectedDateObj.getHours() % 12 : 12;,

                # minutes;, padded with leading zero e.g. 09
                'i': def (): return pad(self.selectedDateObj.getMinutes());,

                'M': def (): return pad(self.selectedDateObj.getMinutes());,

                # day in month (1-30)
                'j': def (): return self.selectedDateObj.getDate();,

                # padded month number (01-12)
                'm': def (): return pad(self.formats.n());,

                # the month number (1-12)
                'n': def (): return self.selectedDateObj.getMonth() + 1;,

                # seconds 0-59
                's': def (): return self.selectedDateObj.getSeconds();,

                # number of the day of the week
                'w': def (): return self.selectedDateObj.getDay();,

                # last two digits of year e.g. 16 for 2016
                'y': def (): return String(self.formats.Y()).substring(2)
    }
    self.formats = formats
    result = ''
    for word in format:
        if formats[word]:
           word = formats[word]()
        result += word
    return result

date.format = format_date

date.now = def (): return Date()

month = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]

array = [ρσ_list_constructor, Array]

configuration = {}
configuration.client = False
configuration.url = False
configuration.exception = exception
configuration.warning = warning
configuration.ajax_load = ajax_load
configuration.ajax_resolve = ajax_resolve
configuration.ajax_reject = ajax_reject

def query(db, type, args, limit):
    makeDocID = db.rel.makeDocID;
    default_selector = {'_id': {'$gt': makeDocID({'type': type}), '$lt': makeDocID({'type': type, 'id': {}})}}
    #like_selector = {}
    #in_selectors = []
    selectors = [] #{'_id': {'$gt': makeDocID({'type': type}), '$lt': makeDocID({'type': type, 'id': {}})}}]
    promises = []
    excepts = []
    except_ids = {}
    index = 0;
    need_orm_operation = False
    for arg in args:
        need_orm = None
        if not arg or not arg[0] or not arg[0].length: continue
        selectors[index] = copy(default_selector);
        if arg[0] == 'id':
           selectors[index]._id = {}
           if is_array(arg[2]):
              arg[2] = arg[2].map(
              def (id):
                  return makeDocID({'type': type, 'id': id})
              )
           else: arg[2] = makeDocID({'type': type, 'id': arg[2]})
           arg[0] = '_id';
        else: arg[0] = 'data.' + arg[0];
        if not selectors[index][arg[0]]:
           selectors[index][arg[0]] = {}
        if arg[1] == '=':
           if arg[2] != False: selectors[index][arg[0]]['$eq'] =  arg[2];
           else: selectors[index][arg[0]]['$lte'] = False;
        elif arg[1] == '!=':
           if arg[0] == '_id':
              except_ids[arg[2]] = True
              selectors.pop(index)
              continue
           if arg[2] != False:
              queries = []
              #queries.push(db.find({'selector': copy(default_selector),'fields': ['_id']}))
              for operator in ['eq']: #, 'gt', 'lt']:
                  selector = copy(default_selector)
                  selector[arg[0]] = {'$' + operator: arg[2]}
                  query = db.find({'selector': selector, 'fields': ['_id']})
                  queries.push(query)
              excepts.push(Promise.all(queries).then(
              def (result):
                  #equal, greater, less = result
                  #all, equal = result
                  equal = result[0]
                  for doc in equal.docs: except_ids[doc._id] = True
                  return
                  #ids = [doc._id for doc in equal.docs]
                  #if not ids.length: return all
                  #all.docs = [doc for doc in all.docs if doc._id not in ids] #[doc for doc in greater.docs if doc._id not in ids].concat(less.docs)
                  #return all
              ))
           else:
              selectors[index][arg[0]]['$gt'] = False;
        elif arg[1] == '>': selectors[index][arg[0]]['$gt'] = v"typeof arg[2] === 'number' ? (arg[2] + 0.000000000000001) : arg[2]";
        elif arg[1] == '>=': selectors[index][arg[0]]['$gte'] = arg[2];
        elif arg[1] == '<': selectors[index][arg[0]]['$lt'] = arg[2];
        elif arg[1] == '<=': selectors[index][arg[0]]['$lte'] = arg[2];
        elif arg[1] == 'in' and is_array(arg[2]):
           in_promises = []
           for value in arg[2]:
               selector = copy(default_selector)
               selector[arg[0]] = {'$eq': value}
               #in_selectors.push(selector)
               in_promises.push(db.find({'selector': selector, 'fields': ['_id']}));
           if not arg[2].length:
              return new Promise(
              def (resolve, reject):
                  return resolve([])
              )
           promises.push(Promise.all(in_promises).then(
           def (results):
               object = {'docs': []}
               for result in results:
                   object.docs = object.docs.concat(result.docs)
               return object
           ))
        elif arg[1] == 'not in' and is_array(arg[2]):
           if arg[0] == '_id':
              for id in arg[2]: except_ids[id] = True
              selectors.pop(index)
              continue
           [[arg[0], value] for value in arg[2]].forEach(
           def (result):
               field, value = result
               queries = []
               #queries.push(db.find({'selector': copy(default_selector),'fields': ['_id']}))
               for operator in ['eq']: #, 'gt', 'lt']:
                   selector = copy(default_selector)
                   selector[field] = {'$' + operator: value}
                   query = db.find({'selector': selector, 'fields': ['_id']})
                   queries.push(query)
               excepts.push(Promise.all(queries).then(
               def (result):
                   #equal, greater, less = result
                   #all, equal = result
                   equal = result[0]
                   for doc in equal.docs: except_ids[doc._id] = True
                   return
                   #ids = [doc._id for doc in equal.docs]
                   #if not ids.length: return all
                   #all.docs = [doc for doc in all.docs if doc._id not in ids] #[doc for doc in greater.docs if doc._id not in ids].concat(less.docs)
                   #return all
               ))
           )
        elif arg[1] == 'like':
           #selectors[index]
           #like_selector[arg[0]]['$regex'] =  arg[2];
           #selectors[index][arg[0]]['$gte'] = arg[2];
           #promises.push(db.search({query: arg[2], 'fields': [arg[0]], include_docs: False}));
           need_orm = True;
        elif arg[1] == 'ilike':
           #selectors[index]
           #like_selector[arg[0]]['$regex'] =  RegExp(arg[2], 'i') if db.adapter not in ['http', 'https'] else '(?i)' + arg[2];
           #selectors[index][arg[0]]['$gte'] = arg[2];
           #promises.push(db.search({query: arg[2], 'fields': [arg[0]], include_docs: False}));
           need_orm = True;
        if need_orm: need_orm_operation = True
        if not Object.keys(selectors[index][arg[0]]).length:
           del selectors[index][arg[0]];
           selectors.pop(index);
           if not need_orm: arg.splice(0, arg.length)
           elif arg[0] != 'id': arg[0] = arg[0][5:] #.replace('data.', '')
           continue;
        if not need_orm: arg.splice(0, arg.length);
        elif arg[0] != 'id': arg[0] = arg[0][5:] #.replace('data.', '')
        index += 1;
    if not selectors.length and not promises.length:
       promises.push(db.find({'selector': default_selector, 'fields': ['_id']}))
    for selector in selectors:
        promises.push(db.find({'selector': selector, 'fields': ['_id']}))
    promises.push(*excepts)
    return Promise.all(promises).then(
    def (results):
        if excepts.length: results.splice(-excepts.length)
        ids = []
        ids_map = {}
        index = 0
        for result in results:
            for doc in result.docs:
                if doc._id in except_ids: continue
                if index == 0: ids_map[doc._id] = 1
                elif doc._id in ids_map: ids_map[doc._id] += 1
                if ids_map[doc._id] == results.length: ids.push(db.rel.parseDocID(doc._id).id)
            index += 1
        #if promises.length > 1:
           #ids = ids.filter(
           #def (value, index, self):
           #    return self.indexOf(value) != index
           #)
        #ids = ids.map(
        #def (id): return db.rel.parseDocID(id).id
        #)
        length = ids.length
        if limit and not need_orm_operation:
           ids = ids[0:limit]
        ids._search_count = length
        return ids
    )

v"""
if (typeof window !== 'undefined' && typeof window.HTMLBodyElement !== 'undefined') {configuration.client = true}
else {configuration.client = false}
"""

def parseURI(data):
    array = []
    for key in data:
        if data[key] not in [True, False, None, undefined]:
           if type(data[key]) in array or type(data) == Object:
              try:
                  data[key] = JSON.stringify(data[key])
              except:
                  pass
        elif data[key] == '':
           data[key] = None
        array.push(encodeURIComponent(key)+ '=' + encodeURIComponent(data[key]))
    return array.join('&')

#XMLHttpRequest for node.js
v"""/**
 * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.
 *
 * This can be used with JS designed for browsers to improve reuse of code and
 * allow the use of existing libraries.
 *
 * Usage: include("XMLHttpRequest.js") and use XMLHttpRequest per W3C specs.
 *
 * @author Dan DeFelippi <dan@driverdan.com>
 * @contributor David Ellis <d.f.ellis@ieee.org>
 * @license MIT
 */

if (typeof window === 'undefined') {
var Url = require("url");
var spawn = require("child_process").spawn;
var fs = require("fs");

var XMLHttpRequest = function() {
  "use strict";

  /**
   * Private variables
   */
  var self = this;
  var http = require("http");
  var https = require("https");

  // Holds http.js objects
  var request;
  var response;

  // Request settings
  var settings = {};

  // Disable header blacklist.
  // Not part of XHR specs.
  var disableHeaderCheck = false;

  // Set some default headers
  var defaultHeaders = {
    "User-Agent": "node-XMLHttpRequest",
    "Accept": "*/*",
  };

  var headers = {};
  var headersCase = {};

  // These headers are not user setable.
  // The following are allowed but banned in the spec:
  // * user-agent
  var forbiddenRequestHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "content-transfer-encoding",
    "cookie",
    "cookie2",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "via"
  ];

  // These request methods are not allowed
  var forbiddenRequestMethods = [
    "TRACE",
    "TRACK",
    "CONNECT"
  ];

  // Send flag
  var sendFlag = false;
  // Error flag, used when errors occur or abort is called
  var errorFlag = false;

  // Event listeners
  var listeners = {};

  /**
   * Constants
   */

  this.UNSENT = 0;
  this.OPENED = 1;
  this.HEADERS_RECEIVED = 2;
  this.LOADING = 3;
  this.DONE = 4;

  /**
   * Public vars
   */

  // Current state
  this.readyState = this.UNSENT;

  // default ready state change handler in case one is not set or is set late
  this.onreadystatechange = null;

  // Result & response
  this.responseText = "";
  this.responseXML = "";
  this.status = null;
  this.statusText = null;
  
  // Whether cross-site Access-Control requests should be made using
  // credentials such as cookies or authorization headers
  this.withCredentials = false;

  /**
   * Private methods
   */

  /**
   * Check if the specified header is allowed.
   *
   * @param string header Header to validate
   * @return boolean False if not allowed, otherwise true
   */
  var isAllowedHttpHeader = function(header) {
    return disableHeaderCheck || (header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1);
  };

  /**
   * Check if the specified method is allowed.
   *
   * @param string method Request method to validate
   * @return boolean False if not allowed, otherwise true
   */
  var isAllowedHttpMethod = function(method) {
    return (method && forbiddenRequestMethods.indexOf(method) === -1);
  };

  /**
   * Public methods
   */

  /**
   * Open the connection. Currently supports local server requests.
   *
   * @param string method Connection method (eg GET, POST)
   * @param string url URL for the connection.
   * @param boolean async Asynchronous connection. Default is true.
   * @param string user Username for basic authentication (optional)
   * @param string password Password for basic authentication (optional)
   */
  this.open = function(method, url, async, user, password) {
    this.abort();
    errorFlag = false;

    // Check for valid request method
    if (!isAllowedHttpMethod(method)) {
      throw new Error("SecurityError: Request method not allowed");
    }

    settings = {
      "method": method,
      "url": url.toString(),
      "async": (typeof async !== "boolean" ? true : async),
      "user": user || null,
      "password": password || null
    };

    setState(this.OPENED);
  };

  /**
   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.
   * This does not conform to the W3C spec.
   *
   * @param boolean state Enable or disable header checking.
   */
  this.setDisableHeaderCheck = function(state) {
    disableHeaderCheck = state;
  };

  /**
   * Sets a header for the request or appends the value if one is already set.
   *
   * @param string header Header name
   * @param string value Header value
   */
  this.setRequestHeader = function(header, value) {
    if (this.readyState !== this.OPENED) {
      throw new Error("INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN");
    }
    if (!isAllowedHttpHeader(header)) {
      console.warn('Refused to set unsafe header "' + header + '"');
      return;
    }
    if (sendFlag) {
      throw new Error("INVALID_STATE_ERR: send flag is true");
    }
    header = headersCase[header.toLowerCase()] || header;
    headersCase[header.toLowerCase()] = header;
    headers[header] = headers[header] ? headers[header] + ', ' + value : value;
  };

  /**
   * Gets a header from the server response.
   *
   * @param string header Name of header to get.
   * @return string Text of the header or null if it doesn't exist.
   */
  this.getResponseHeader = function(header) {
    if (typeof header === "string"
      && this.readyState > this.OPENED
      && response
      && response.headers
      && response.headers[header.toLowerCase()]
      && !errorFlag
    ) {
      return response.headers[header.toLowerCase()];
    }

    return null;
  };

  /**
   * Gets all the response headers.
   *
   * @return string A string with all response headers separated by CR+LF
   */
  this.getAllResponseHeaders = function() {
    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {
      return "";
    }
    var result = "";

    for (var i in response.headers) {
      // Cookie headers are excluded
      if (i !== "set-cookie" && i !== "set-cookie2") {
        result += i + ": " + response.headers[i] + "\\r\\n";
      }
    }
    return result.substr(0, result.length - 2);
  };

  /**
   * Gets a request header
   *
   * @param string name Name of header to get
   * @return string Returns the request header or empty string if not set
   */
  this.getRequestHeader = function(name) {
    if (typeof name === "string" && headersCase[name.toLowerCase()]) {
      return headers[headersCase[name.toLowerCase()]];
    }

    return "";
  };

  /**
   * Sends the request to the server.
   *
   * @param string data Optional data to send as request body.
   */
  this.send = function(data) {
    if (this.readyState !== this.OPENED) {
      throw new Error("INVALID_STATE_ERR: connection must be opened before send() is called");
    }

    if (sendFlag) {
      throw new Error("INVALID_STATE_ERR: send has already been called");
    }

    var ssl = false, local = false;
    var url = Url.parse(settings.url);
    var host;
    // Determine the server
    switch (url.protocol) {
      case "https:":
        ssl = true;
        // SSL & non-SSL both need host, no break here.
      case "http:":
        host = url.hostname;
        break;

      case "file:":
        local = true;
        break;

      case undefined:
      case null:
      case "":
        host = "localhost";
        break;

      default:
        throw new Error("Protocol not supported.");
    }

    // Load files off the local filesystem (file://)
    if (local) {
      if (settings.method !== "GET") {
        throw new Error("XMLHttpRequest: Only GET method is supported");
      }

      if (settings.async) {
        fs.readFile(url.pathname, "utf8", function(error, data) {
          if (error) {
            self.handleError(error);
          } else {
            self.status = 200;
            self.responseText = data;
            setState(self.DONE);
          }
        });
      } else {
        try {
          this.responseText = fs.readFileSync(url.pathname, "utf8");
          this.status = 200;
          setState(self.DONE);
        } catch(e) {
          this.handleError(e);
        }
      }

      return;
    }

    // Default to port 80. If accessing localhost on another port be sure
    // to use http://localhost:port/path
    var port = url.port || (ssl ? 443 : 80);
    // Add query string if one is used
    var uri = url.pathname + (url.search ? url.search : "");

    // Set the defaults if they haven't been set
    for (var name in defaultHeaders) {
      if (!headersCase[name.toLowerCase()]) {
        headers[name] = defaultHeaders[name];
      }
    }

    // Set the Host header or the server may reject the request
    headers.Host = host;
    if (!((ssl && port === 443) || port === 80)) {
      headers.Host += ":" + url.port;
    }

    // Set Basic Auth if necessary
    if (settings.user) {
      if (typeof settings.password === "undefined") {
        settings.password = "";
      }
      var authBuf = new Buffer(settings.user + ":" + settings.password);
      headers.Authorization = "Basic " + authBuf.toString("base64");
    }

    // Set content length header
    if (settings.method === "GET" || settings.method === "HEAD") {
      data = null;
    } else if (data) {
      headers["Content-Length"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);

      if (!headers["Content-Type"]) {
        headers["Content-Type"] = "text/plain;charset=UTF-8";
      }
    } else if (settings.method === "POST") {
      // For a post with no data set Content-Length: 0.
      // This is required by buggy servers that don't meet the specs.
      headers["Content-Length"] = 0;
    }

    var options = {
      host: host,
      port: port,
      path: uri,
      method: settings.method,
      headers: headers,
      agent: false,
      withCredentials: self.withCredentials
    };

    // Reset error flag
    errorFlag = false;

    // Handle async requests
    if (settings.async) {
      // Use the proper protocol
      var doRequest = ssl ? https.request : http.request;

      // Request is being sent, set send flag
      sendFlag = true;

      // As per spec, this is called here for historical reasons.
      self.dispatchEvent("readystatechange");

      // Handler for the response
      var responseHandler = function responseHandler(resp) {
        // Set response var to the response we got back
        // This is so it remains accessable outside this scope
        response = resp;
        // Check for redirect
        // @TODO Prevent looped redirects
        if (response.statusCode === 301 || response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {
          // Change URL to the redirect location
          settings.url = response.headers.location;
          var url = Url.parse(settings.url);
          // Set host var in case it's used later
          host = url.hostname;
          // Options for the new request
          var newOptions = {
            hostname: url.hostname,
            port: url.port,
            path: url.path,
            method: response.statusCode === 303 ? "GET" : settings.method,
            headers: headers,
            withCredentials: self.withCredentials
          };

          // Issue the new request
          request = doRequest(newOptions, responseHandler).on("error", errorHandler);
          request.end();
          // @TODO Check if an XHR event needs to be fired here
          return;
        }

        response.setEncoding("utf8");

        setState(self.HEADERS_RECEIVED);
        self.status = response.statusCode;

        response.on("data", function(chunk) {
          // Make sure there's some data
          if (chunk) {
            self.responseText += chunk;
          }
          // Don't emit state changes if the connection has been aborted.
          if (sendFlag) {
            setState(self.LOADING);
          }
        });

        response.on("end", function() {
          if (sendFlag) {
            // Discard the end event if the connection has been aborted
            setState(self.DONE);
            sendFlag = false;
          }
        });

        response.on("error", function(error) {
          self.handleError(error);
        });
      };

      // Error handler for the request
      var errorHandler = function errorHandler(error) {
        self.handleError(error);
      };

      // Create the request
      request = doRequest(options, responseHandler).on("error", errorHandler);

      // Node 0.4 and later won't accept empty data. Make sure it's needed.
      if (data) {
        request.write(data);
      }

      request.end();

      self.dispatchEvent("loadstart");
    } else { // Synchronous
      // Create a temporary file for communication with the other Node process
      var contentFile = ".node-xmlhttprequest-content-" + process.pid;
      var syncFile = ".node-xmlhttprequest-sync-" + process.pid;
      fs.writeFileSync(syncFile, "", "utf8");
      // The async request the other Node process executes
      var execString = "var http = require('http'), https = require('https'), fs = require('fs');"
        + "var doRequest = http" + (ssl ? "s" : "") + ".request;"
        + "var options = " + JSON.stringify(options) + ";"
        + "var responseText = '';"
        + "var req = doRequest(options, function(response) {"
        + "response.setEncoding('utf8');"
        + "response.on('data', function(chunk) {"
        + "  responseText += chunk;"
        + "});"
        + "response.on('end', function() {"
        + "fs.writeFileSync('" + contentFile + "', JSON.stringify({err: null, data: {statusCode: response.statusCode, headers: response.headers, text: responseText}}), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + "response.on('error', function(error) {"
        + "fs.writeFileSync('" + contentFile + "', JSON.stringify({err: error}), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + "}).on('error', function(error) {"
        + "fs.writeFileSync('" + contentFile + "', JSON.stringify({err: error}), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + (data ? "req.write('" + JSON.stringify(data).slice(1,-1).replace(/'/g, "\\'") + "');":"")
        + "req.end();";
      // Start the other Node Process, executing this string
      var syncProc = spawn(process.argv[0], ["-e", execString]);
      while(fs.existsSync(syncFile)) {
        // Wait while the sync file is empty
      }
      var resp = JSON.parse(fs.readFileSync(contentFile, 'utf8'));
      // Kill the child process once the file has data
      syncProc.stdin.end();
      // Remove the temporary file
      fs.unlinkSync(contentFile);

      if (resp.err) {
        self.handleError(resp.err);
      } else {
        response = resp.data;
        self.status = resp.data.statusCode;
        self.responseText = resp.data.text;
        setState(self.DONE);
      }
    }
  };

  /**
   * Called when an error is encountered to deal with it.
   */
  this.handleError = function(error) {
    this.status = 0;
    this.statusText = error;
    this.responseText = error.stack;
    errorFlag = true;
    setState(this.DONE);
    this.dispatchEvent('error');
  };

  /**
   * Aborts a request.
   */
  this.abort = function() {
    if (request) {
      request.abort();
      request = null;
    }

    headers = defaultHeaders;
    this.status = 0;
    this.responseText = "";
    this.responseXML = "";

    errorFlag = true;

    if (this.readyState !== this.UNSENT
        && (this.readyState !== this.OPENED || sendFlag)
        && this.readyState !== this.DONE) {
      sendFlag = false;
      setState(this.DONE);
    }
    this.readyState = this.UNSENT;
    this.dispatchEvent('abort');
  };

  /**
   * Adds an event listener. Preferred method of binding to events.
   */
  this.addEventListener = function(event, callback) {
    if (!(event in listeners)) {
      listeners[event] = [];
    }
    // Currently allows duplicate callbacks. Should it?
    listeners[event].push(callback);
  };

  /**
   * Remove an event callback that has already been bound.
   * Only works on the matching funciton, cannot be a copy.
   */
  this.removeEventListener = function(event, callback) {
    if (event in listeners) {
      // Filter will return a new array with the callback removed
      listeners[event] = listeners[event].filter(function(ev) {
        return ev !== callback;
      });
    }
  };

  /**
   * Dispatch any events, including both "on" methods and events attached using addEventListener.
   */
  this.dispatchEvent = function(event) {
    if (typeof self["on" + event] === "function") {
      self["on" + event]();
    }
    if (event in listeners) {
      for (var i = 0, len = listeners[event].length; i < len; i++) {
        listeners[event][i].call(self);
      }
    }
  };

  /**
   * Changes readyState and calls onreadystatechange.
   *
   * @param int state New state
   */
  var setState = function(state) {
    if (state == self.LOADING || self.readyState !== state) {
      self.readyState = state;

      if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {
        self.dispatchEvent("readystatechange");
      }

      if (self.readyState === self.DONE && !errorFlag) {
        self.dispatchEvent("load");
        // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)
        self.dispatchEvent("loadend");
      }
    }
  };
};
}else{
var XMLHttpRequest = window.XMLHttpRequest;
}"""

def ajax_load():
    return

def ajax_resolve(resolve, xhr, opts):
    resolve(xhr.response)

def ajax_reject(reject, xhr, opts):
    reject(xhr.statusText)

def ajax(type, dataType, url, data, opts):
    if not exist(opts):
       opts = {}
    configuration.ajax_load(opts)
    if exist(data):
       data = parseURI(data)
    return Promise(
    def (resolve, reject):
        xhr = XMLHttpRequest()
        xhr.open(type, url, True)
        xhr.onload = def(): configuration.ajax_resolve(resolve, this, opts)
        xhr.onerror = def(): configuration.ajax_reject(reject, this, opts)
        xhr.responseType = dataType
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
        try:
            xhr.send(data)
        except Exception as error:
            reject(error)
    )

#Polyfill Array.find
v"""if (!Array.prototype.find) {
  Object.defineProperty(Array.prototype, 'find', {
    value: function(predicate) {
     // 1. Let O be ? ToObject(this value).
      if (this == null) {
        throw new TypeError('"this" is null or not defined');
      }

      var o = Object(this);

      // 2. Let len be ? ToLength(? Get(O, "length")).
      var len = o.length >>> 0;

      // 3. If IsCallable(predicate) is false, throw a TypeError exception.
      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      }

      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
      var thisArg = arguments[1];

      // 5. Let k be 0.
      var k = 0;

      // 6. Repeat, while k < len
      while (k < len) {
        // a. Let Pk be ! ToString(k).
        // b. Let kValue be ? Get(O, Pk).
        // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
        // d. If testResult is true, return kValue.
        var kValue = o[k];
        if (predicate.call(thisArg, kValue, k, o)) {
          return kValue;
        }
        // e. Increase k by 1.
        k++;
      }

      // 7. Return undefined.
      return undefined;
    }
  });
}"""

#Polyfill Array.filter
v"""if (!Array.prototype.filter)
  Array.prototype.filter = function(func, thisArg) {
    'use strict';
    if ( ! ((typeof func === 'Function' || typeof func === 'function') && this) )
        throw new TypeError();
    
    var len = this.length >>> 0,
        res = new Array(len), // preallocate array
        t = this, c = 0, i = -1;
    if (thisArg === undefined)
      while (++i !== len)
        // checks to see if the key was set
        if (i in this)
          if (func(t[i], i, t))
            res[c++] = t[i];
    else
      while (++i !== len)
        // checks to see if the key was set
        if (i in this)
          if (func.call(thisArg, t[i], i, t))
            res[c++] = t[i];
    
    res.length = c; // shrink down array to proper size
    return res;
  };"""

#Polyfill Array.every
v"""if (!Array.prototype.every) {
  Array.prototype.every = function(callbackfn, thisArg) {
    'use strict';
    var T, k;

    if (this == null) {
      throw new TypeError('this is null or not defined');
    }

    // 1. Let O be the result of calling ToObject passing the this 
    //    value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get internal method
    //    of O with the argument "length".
    // 3. Let len be ToUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.
    if (typeof callbackfn !== 'function') {
      throw new TypeError();
    }

    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    if (arguments.length > 1) {
      T = thisArg;
    }

    // 6. Let k be 0.
    k = 0;

    // 7. Repeat, while k < len
    while (k < len) {

      var kValue;

      // a. Let Pk be ToString(k).
      //   This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty internal 
      //    method of O with argument Pk.
      //   This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal method
        //    of O with argument Pk.
        kValue = O[k];

        // ii. Let testResult be the result of calling the Call internal method
        //     of callbackfn with T as the this value and argument list 
        //     containing kValue, k, and O.
        var testResult = callbackfn.call(T, kValue, k, O);

        // iii. If ToBoolean(testResult) is false, return false.
        if (!testResult) {
          return false;
        }
      }
      k++;
    }
    return true;
  };
}"""

#Polyfill Array.some
v"""// Production steps of ECMA-262, Edition 5, 15.4.4.17
// Reference: http://es5.github.io/#x15.4.4.17
if (!Array.prototype.some) {
  Array.prototype.some = function(fun/*, thisArg*/) {
    'use strict';

    if (this == null) {
      throw new TypeError('Array.prototype.some called on null or undefined');
    }

    if (typeof fun !== 'function') {
      throw new TypeError();
    }

    var t = Object(this);
    var len = t.length >>> 0;

    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
    for (var i = 0; i < len; i++) {
      if (i in t && fun.call(thisArg, t[i], i, t)) {
        return true;
      }
    }

    return false;
  };
}"""

#Polyfill Object.entries
v"""if (!Object.entries)
  Object.entries = function( obj ){
    var ownProps = Object.keys( obj ),
        i = ownProps.length,
        resArray = new Array(i); // preallocate the Array
    while (i--)
      resArray[i] = [ownProps[i], obj[ownProps[i]]];
    
    return resArray;
  };
"""
